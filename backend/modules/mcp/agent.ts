/**
 * MCP (Model Context Protocol) Agent
 *
 * This agent provides AI-powered tools through the MCP protocol.
 * It supports both SSE (Server-Sent Events) and Streamable HTTP transports.
 *
 * Learn more about MCP: https://modelcontextprotocol.io/
 * Cloudflare Docs: https://developers.cloudflare.com/agents/model-context-protocol/
 */

import { McpAgent } from 'agents/mcp'
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { z } from 'zod'

/**
 * Type definition for the Worker environment bindings
 * Generated by `wrangler types` command
 */
type Env = {
  AI: Ai
  DB: D1Database
  GEMINI_API_KEY: string
  // Add MCP-specific env vars if needed
  MCP_SERVER_NAME?: string
  MCP_SERVER_VERSION?: string
}

/**
 * CloudflareMcpAgent
 *
 * A production-ready MCP server that demonstrates:
 * - Tool definitions with Zod schema validation
 * - Integration with Cloudflare Workers AI
 * - D1 database access
 * - Proper error handling
 * - Type safety throughout
 *
 * Usage:
 * - Extend this class to add more tools
 * - Each tool is automatically documented via Zod schemas
 * - Tools can access Cloudflare bindings via `this.env`
 */
export class CloudflareMcpAgent extends McpAgent<Env> {
  /**
   * Initialize the MCP server with metadata
   * Name and version will be visible to MCP clients
   */
  server = new McpServer({
    name: 'cloudflare-worker-mcp',
    version: '1.0.0',
  })

  /**
   * Initialize all tools when the agent starts
   * This is called automatically by the McpAgent framework
   */
  async init() {
    // Register all tools
    this.registerEchoTool()
    this.registerCalculatorTool()
    this.registerHealthCheckTool()
    this.registerAiTool()
    this.registerDatabaseTool()
  }

  /**
   * TOOL: Echo
   * Simple demonstration tool that echoes back the input
   * Useful for testing MCP client connectivity
   */
  private registerEchoTool() {
    this.server.tool(
      'echo',
      'Echoes back the provided message. Useful for testing connectivity.',
      {
        message: z.string().describe('The message to echo back'),
      },
      async ({ message }) => {
        return {
          content: [
            {
              type: 'text',
              text: `Echo: ${message}`,
            },
          ],
        }
      }
    )
  }

  /**
   * TOOL: Calculator
   * Performs basic arithmetic operations
   * Demonstrates parameter validation and error handling
   */
  private registerCalculatorTool() {
    this.server.tool(
      'calculate',
      'Performs basic arithmetic operations (add, subtract, multiply, divide)',
      {
        operation: z
          .enum(['add', 'subtract', 'multiply', 'divide'])
          .describe('The arithmetic operation to perform'),
        a: z.number().describe('First number'),
        b: z.number().describe('Second number'),
      },
      async ({ operation, a, b }) => {
        let result: number

        switch (operation) {
          case 'add':
            result = a + b
            break
          case 'subtract':
            result = a - b
            break
          case 'multiply':
            result = a * b
            break
          case 'divide':
            if (b === 0) {
              return {
                content: [
                  {
                    type: 'text',
                    text: 'Error: Division by zero is not allowed',
                  },
                ],
                isError: true,
              }
            }
            result = a / b
            break
        }

        return {
          content: [
            {
              type: 'text',
              text: `Result: ${a} ${operation} ${b} = ${result}`,
            },
          ],
        }
      }
    )
  }

  /**
   * TOOL: Health Check
   * Returns the health status of the worker and its bindings
   * Useful for monitoring and diagnostics
   */
  private registerHealthCheckTool() {
    this.server.tool(
      'healthCheck',
      'Check the health status of the Worker and its bindings',
      {},
      async () => {
        const health = {
          status: 'healthy',
          timestamp: new Date().toISOString(),
          bindings: {
            ai: !!this.env.AI,
            db: !!this.env.DB,
            gemini: !!this.env.GEMINI_API_KEY,
          },
        }

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(health, null, 2),
            },
          ],
        }
      }
    )
  }

  /**
   * TOOL: AI Text Generation
   * Uses Cloudflare Workers AI to generate text
   * Demonstrates integration with Cloudflare AI binding
   */
  private registerAiTool() {
    this.server.tool(
      'generateText',
      'Generate text using Cloudflare Workers AI',
      {
        prompt: z.string().describe('The prompt for text generation'),
        maxTokens: z
          .number()
          .optional()
          .default(256)
          .describe('Maximum number of tokens to generate'),
      },
      async ({ prompt, maxTokens }) => {
        try {
          // Use Cloudflare Workers AI
          const response = await this.env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
            prompt,
            max_tokens: maxTokens,
          })

          return {
            content: [
              {
                type: 'text',
                text: response.response || 'No response generated',
              },
            ],
          }
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
              },
            ],
            isError: true,
          }
        }
      }
    )
  }

  /**
   * TOOL: Database Query
   * Executes a read-only query on the D1 database
   * Demonstrates D1 integration with safety checks
   */
  private registerDatabaseTool() {
    this.server.tool(
      'queryDatabase',
      'Execute a read-only SQL query on the D1 database',
      {
        query: z
          .string()
          .describe('SQL query to execute (SELECT queries only for safety)'),
      },
      async ({ query }) => {
        // Security: Only allow SELECT queries
        const normalizedQuery = query.trim().toLowerCase()
        if (!normalizedQuery.startsWith('select')) {
          return {
            content: [
              {
                type: 'text',
                text: 'Error: Only SELECT queries are allowed for safety reasons',
              },
            ],
            isError: true,
          }
        }

        try {
          const result = await this.env.DB.prepare(query).all()

          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify(result, null, 2),
              },
            ],
          }
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Database error: ${error instanceof Error ? error.message : 'Unknown error'}`,
              },
            ],
            isError: true,
          }
        }
      }
    )
  }
}

/**
 * Export a singleton instance of the MCP agent
 * This is the recommended pattern for Cloudflare Workers
 */
export const mcpAgent = CloudflareMcpAgent
